import{C as G}from"./codemirror.es.f9aaa881.js";import{o as He}from"./types.es.cd67e374.js";import{C as We,R as Ne,P as U}from"./Range.es.dcc00501.js";import{t as h,d as fe,i as pe,T as ve,v as ye,a as ze}from"./index.3992c1fc.js";import"./index.64257940.js";import{p as v,v as Ie,a as Ze}from"./index.27788710.js";import{K as u,G as d,f as y,c as T,D as E,O as J,d as xe,g as en}from"./parser.542c3b4e.js";import{R as b,b as he,c as w,U as Oe,d as F,V as R,t as $,W as B,X as nn,Y as tn,u as O,a as k,i as I,x as V,z as rn,m as on,n as De,o as C,j as _e,Z as j,F as sn,_ as an,$ as cn,a0 as ln,v as un,q as fn,h as pn}from"./index.bf34cfca.js";import"./index.5b2f5049.js";import"./Dropdown.66094b27.js";import"./index.61964446.js";import"./Portal.bf2e5144.js";import"./type.4482a080.js";import"./Overflow.ff04d686.js";import"./statusUtils.e7207d24.js";import"./context.4fcda71f.js";import"./_baseIsEqual.ae1f3f6e.js";import"./omit.173224d8.js";import"./PlusOutlined.3088ee84.js";import"./Tree.0082570b.js";import"./isSymbol.d728fe31.js";import"./index.39cec35d.js";import"./pickAttrs.91b30b21.js";import"./conductUtil.91a30912.js";import"./iconUtil.71342ca5.js";import"./SearchOutlined.d2d234c2.js";import"./button.ca276c4e.js";import"./Helmet.90e2ca49.js";import"./index.d4e5ccca.js";import"./isArrayLikeObject.9676d780.js";import"./get.ab779695.js";import"./identity.af5bbf98.js";import"./_copyArray.ed92a2fd.js";import"./index.9d56ca15.js";import"./row.04cc9265.js";import"./styleChecker.9486324a.js";import"./responsiveObserve.a761adf9.js";import"./index.4ef503cf.js";import"./workbenchContext.4d536977.js";import"./index.e3184aa5.js";import"./index.21d0aee3.js";import"./utils.435ff07e.js";import"./DialogWrap.ed68ac9f.js";import"./index.e073bbb6.js";import"./path.02380b0b.js";import"./Editor.88c5e82e.js";import"./use-immer.module.72e4ecef.js";import"./index.70ebfd77.js";import"./stackblitz.d6583d31.js";import"./index.46a9404e.js";import"./dayjs.min.9104a23a.js";import"./DoubleRightOutlined.d12d812f.js";import"./index.93b57069.js";import"./EyeOutlined.8d71b64e.js";import"./index.e257c064.js";import"./RightOutlined.ce6e99f7.js";import"./Sider.4bd14ece.js";import"./index.114f7a19.js";import"./main.6509447f.js";import"./index.e939beeb.js";import"./index.c6a78d56.js";import"./index.5c556af0.js";import"./utils.02fb0c25.js";import"./DeleteOutlined.ab1eeec0.js";import"./index.22218f67.js";import"./main.5d92847d.js";function dn(e){return e.kind===u.OPERATION_DEFINITION||e.kind===u.FRAGMENT_DEFINITION}function mn(e){return e.kind===u.SCHEMA_DEFINITION||q(e)||e.kind===u.DIRECTIVE_DEFINITION}function q(e){return e.kind===u.SCALAR_TYPE_DEFINITION||e.kind===u.OBJECT_TYPE_DEFINITION||e.kind===u.INTERFACE_TYPE_DEFINITION||e.kind===u.UNION_TYPE_DEFINITION||e.kind===u.ENUM_TYPE_DEFINITION||e.kind===u.INPUT_OBJECT_TYPE_DEFINITION}function gn(e){return e.kind===u.SCHEMA_EXTENSION||be(e)}function be(e){return e.kind===u.SCALAR_TYPE_EXTENSION||e.kind===u.OBJECT_TYPE_EXTENSION||e.kind===u.INTERFACE_TYPE_EXTENSION||e.kind===u.UNION_TYPE_EXTENSION||e.kind===u.ENUM_TYPE_EXTENSION||e.kind===u.INPUT_OBJECT_TYPE_EXTENSION}function Se(e){return{Document(n){for(const t of n.definitions)if(!dn(t)){const i=t.kind===u.SCHEMA_DEFINITION||t.kind===u.SCHEMA_EXTENSION?"schema":'"'+t.name.value+'"';e.reportError(new d(`The ${i} definition is not executable.`,{nodes:t}))}return!1}}}function Tn(e){return{Field(n){const t=e.getParentType();if(t&&!e.getFieldDef()){const r=e.getSchema(),o=n.name.value;let a=b("to use an inline fragment on",En(r,t,o));a===""&&(a=b(Nn(t,o))),e.reportError(new d(`Cannot query field "${o}" on type "${t.name}".`+a,{nodes:n}))}}}}function En(e,n,t){if(!he(n))return[];const i=new Set,r=Object.create(null);for(const a of e.getPossibleTypes(n))if(!!a.getFields()[t]){i.add(a),r[a.name]=1;for(const s of a.getInterfaces()){var o;!s.getFields()[t]||(i.add(s),r[s.name]=((o=r[s.name])!==null&&o!==void 0?o:0)+1)}}return[...i].sort((a,s)=>{const c=r[s.name]-r[a.name];return c!==0?c:w(a)&&e.isSubType(a,s)?-1:w(s)&&e.isSubType(s,a)?1:Oe(a.name,s.name)}).map(a=>a.name)}function Nn(e,n){if(F(e)||w(e)){const t=Object.keys(e.getFields());return R(n,t)}return[]}function vn(e){return{InlineFragment(n){const t=n.typeCondition;if(t){const i=h(e.getSchema(),t);if(i&&!$(i)){const r=v(t);e.reportError(new d(`Fragment cannot condition on non composite type "${r}".`,{nodes:t}))}}},FragmentDefinition(n){const t=h(e.getSchema(),n.typeCondition);if(t&&!$(t)){const i=v(n.typeCondition);e.reportError(new d(`Fragment "${n.name.value}" cannot condition on non composite type "${i}".`,{nodes:n.typeCondition}))}}}}function yn(e){return{...we(e),Argument(n){const t=e.getArgument(),i=e.getFieldDef(),r=e.getParentType();if(!t&&i&&r){const o=n.name.value,a=i.args.map(c=>c.name),s=R(o,a);e.reportError(new d(`Unknown argument "${o}" on field "${r.name}.${i.name}".`+b(s),{nodes:n}))}}}}function we(e){const n=Object.create(null),t=e.getSchema(),i=t?t.getDirectives():B;for(const a of i)n[a.name]=a.args.map(s=>s.name);const r=e.getDocument().definitions;for(const a of r)if(a.kind===u.DIRECTIVE_DEFINITION){var o;const s=(o=a.arguments)!==null&&o!==void 0?o:[];n[a.name.value]=s.map(c=>c.name.value)}return{Directive(a){const s=a.name.value,c=n[s];if(a.arguments&&c)for(const l of a.arguments){const f=l.name.value;if(!c.includes(f)){const p=R(f,c);e.reportError(new d(`Unknown argument "${f}" on directive "@${s}".`+b(p),{nodes:l}))}}return!1}}}function ee(e){const n=Object.create(null),t=e.getSchema(),i=t?t.getDirectives():B;for(const o of i)n[o.name]=o.locations;const r=e.getDocument().definitions;for(const o of r)o.kind===u.DIRECTIVE_DEFINITION&&(n[o.name.value]=o.locations.map(a=>a.value));return{Directive(o,a,s,c,l){const f=o.name.value,p=n[f];if(!p){e.reportError(new d(`Unknown directive "@${f}".`,{nodes:o}));return}const m=In(l);m&&!p.includes(m)&&e.reportError(new d(`Directive "@${f}" may not be used on ${m}.`,{nodes:o}))}}}function In(e){const n=e[e.length-1];switch("kind"in n||y(!1),n.kind){case u.OPERATION_DEFINITION:return hn(n.operation);case u.FIELD:return E.FIELD;case u.FRAGMENT_SPREAD:return E.FRAGMENT_SPREAD;case u.INLINE_FRAGMENT:return E.INLINE_FRAGMENT;case u.FRAGMENT_DEFINITION:return E.FRAGMENT_DEFINITION;case u.VARIABLE_DEFINITION:return E.VARIABLE_DEFINITION;case u.SCHEMA_DEFINITION:case u.SCHEMA_EXTENSION:return E.SCHEMA;case u.SCALAR_TYPE_DEFINITION:case u.SCALAR_TYPE_EXTENSION:return E.SCALAR;case u.OBJECT_TYPE_DEFINITION:case u.OBJECT_TYPE_EXTENSION:return E.OBJECT;case u.FIELD_DEFINITION:return E.FIELD_DEFINITION;case u.INTERFACE_TYPE_DEFINITION:case u.INTERFACE_TYPE_EXTENSION:return E.INTERFACE;case u.UNION_TYPE_DEFINITION:case u.UNION_TYPE_EXTENSION:return E.UNION;case u.ENUM_TYPE_DEFINITION:case u.ENUM_TYPE_EXTENSION:return E.ENUM;case u.ENUM_VALUE_DEFINITION:return E.ENUM_VALUE;case u.INPUT_OBJECT_TYPE_DEFINITION:case u.INPUT_OBJECT_TYPE_EXTENSION:return E.INPUT_OBJECT;case u.INPUT_VALUE_DEFINITION:{const t=e[e.length-3];return"kind"in t||y(!1),t.kind===u.INPUT_OBJECT_TYPE_DEFINITION?E.INPUT_FIELD_DEFINITION:E.ARGUMENT_DEFINITION}default:y(!1,"Unexpected kind: "+T(n.kind))}}function hn(e){switch(e){case J.QUERY:return E.QUERY;case J.MUTATION:return E.MUTATION;case J.SUBSCRIPTION:return E.SUBSCRIPTION}}function Fe(e){return{FragmentSpread(n){const t=n.name.value;e.getFragment(t)||e.reportError(new d(`Unknown fragment "${t}".`,{nodes:n.name}))}}}function ne(e){const n=e.getSchema(),t=n?n.getTypeMap():Object.create(null),i=Object.create(null);for(const o of e.getDocument().definitions)q(o)&&(i[o.name.value]=!0);const r=[...Object.keys(t),...Object.keys(i)];return{NamedType(o,a,s,c,l){const f=o.name.value;if(!t[f]&&!i[f]){var p;const m=(p=l[2])!==null&&p!==void 0?p:s,g=m!=null&&On(m);if(g&&de.includes(f))return;const N=R(f,g?de.concat(r):r);e.reportError(new d(`Unknown type "${f}".`+b(N),{nodes:o}))}}}}const de=[...nn,...tn].map(e=>e.name);function On(e){return"kind"in e&&(mn(e)||gn(e))}function Dn(e){let n=0;return{Document(t){n=t.definitions.filter(i=>i.kind===u.OPERATION_DEFINITION).length},OperationDefinition(t){!t.name&&n>1&&e.reportError(new d("This anonymous operation must be the only defined operation.",{nodes:t}))}}}function Re(e){var n,t,i;const r=e.getSchema(),o=(n=(t=(i=r==null?void 0:r.astNode)!==null&&i!==void 0?i:r==null?void 0:r.getQueryType())!==null&&t!==void 0?t:r==null?void 0:r.getMutationType())!==null&&n!==void 0?n:r==null?void 0:r.getSubscriptionType();let a=0;return{SchemaDefinition(s){if(o){e.reportError(new d("Cannot define a new schema within a schema extension.",{nodes:s}));return}a>0&&e.reportError(new d("Must provide only one schema definition.",{nodes:s})),++a}}}function _n(e){const n=Object.create(null),t=[],i=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(o){return r(o),!1}};function r(o){if(n[o.name.value])return;const a=o.name.value;n[a]=!0;const s=e.getFragmentSpreads(o.selectionSet);if(s.length!==0){i[a]=t.length;for(const c of s){const l=c.name.value,f=i[l];if(t.push(c),f===void 0){const p=e.getFragment(l);p&&r(p)}else{const p=t.slice(f),m=p.slice(0,-1).map(g=>'"'+g.name.value+'"').join(", ");e.reportError(new d(`Cannot spread fragment "${l}" within itself`+(m!==""?` via ${m}.`:"."),{nodes:p}))}t.pop()}i[a]=void 0}}}function bn(e){let n=Object.create(null);return{OperationDefinition:{enter(){n=Object.create(null)},leave(t){const i=e.getRecursiveVariableUsages(t);for(const{node:r}of i){const o=r.name.value;n[o]!==!0&&e.reportError(new d(t.name?`Variable "$${o}" is not defined by operation "${t.name.value}".`:`Variable "$${o}" is not defined.`,{nodes:[r,t]}))}}},VariableDefinition(t){n[t.variable.name.value]=!0}}}function $e(e){const n=[],t=[];return{OperationDefinition(i){return n.push(i),!1},FragmentDefinition(i){return t.push(i),!1},Document:{leave(){const i=Object.create(null);for(const r of n)for(const o of e.getRecursivelyReferencedFragments(r))i[o.name.value]=!0;for(const r of t){const o=r.name.value;i[o]!==!0&&e.reportError(new d(`Fragment "${o}" is never used.`,{nodes:r}))}}}}}function Sn(e){let n=[];return{OperationDefinition:{enter(){n=[]},leave(t){const i=Object.create(null),r=e.getRecursiveVariableUsages(t);for(const{node:o}of r)i[o.name.value]=!0;for(const o of n){const a=o.variable.name.value;i[a]!==!0&&e.reportError(new d(t.name?`Variable "$${a}" is never used in operation "${t.name.value}".`:`Variable "$${a}" is never used.`,{nodes:o}))}}},VariableDefinition(t){n.push(t)}}}function te(e){switch(e.kind){case u.OBJECT:return{...e,fields:wn(e.fields)};case u.LIST:return{...e,values:e.values.map(te)};case u.INT:case u.FLOAT:case u.STRING:case u.BOOLEAN:case u.NULL:case u.ENUM:case u.VARIABLE:return e}}function wn(e){return e.map(n=>({...n,value:te(n.value)})).sort((n,t)=>Oe(n.name.value,t.name.value))}function Ce(e){return Array.isArray(e)?e.map(([n,t])=>`subfields "${n}" conflict because `+Ce(t)).join(" and "):e}function Fn(e){const n=new Pn,t=new Map;return{SelectionSet(i){const r=Rn(e,t,n,e.getParentType(),i);for(const[[o,a],s,c]of r){const l=Ce(a);e.reportError(new d(`Fields "${o}" conflict because ${l}. Use different aliases on the fields to fetch both if this was intentional.`,{nodes:s.concat(c)}))}}}}function Rn(e,n,t,i,r){const o=[],[a,s]=Y(e,n,i,r);if(Cn(e,o,n,t,a),s.length!==0)for(let c=0;c<s.length;c++){L(e,o,n,t,!1,a,s[c]);for(let l=c+1;l<s.length;l++)M(e,o,n,t,!1,s[c],s[l])}return o}function L(e,n,t,i,r,o,a){const s=e.getFragment(a);if(!s)return;const[c,l]=H(e,t,s);if(o!==c){ie(e,n,t,i,r,o,c);for(const f of l)i.has(f,a,r)||(i.add(f,a,r),L(e,n,t,i,r,o,f))}}function M(e,n,t,i,r,o,a){if(o===a||i.has(o,a,r))return;i.add(o,a,r);const s=e.getFragment(o),c=e.getFragment(a);if(!s||!c)return;const[l,f]=H(e,t,s),[p,m]=H(e,t,c);ie(e,n,t,i,r,l,p);for(const g of m)M(e,n,t,i,r,o,g);for(const g of f)M(e,n,t,i,r,g,a)}function $n(e,n,t,i,r,o,a,s){const c=[],[l,f]=Y(e,n,r,o),[p,m]=Y(e,n,a,s);ie(e,c,n,t,i,l,p);for(const g of m)L(e,c,n,t,i,l,g);for(const g of f)L(e,c,n,t,i,p,g);for(const g of f)for(const N of m)M(e,c,n,t,i,g,N);return c}function Cn(e,n,t,i,r){for(const[o,a]of Object.entries(r))if(a.length>1)for(let s=0;s<a.length;s++)for(let c=s+1;c<a.length;c++){const l=Ae(e,t,i,!1,o,a[s],a[c]);l&&n.push(l)}}function ie(e,n,t,i,r,o,a){for(const[s,c]of Object.entries(o)){const l=a[s];if(l)for(const f of c)for(const p of l){const m=Ae(e,t,i,r,s,f,p);m&&n.push(m)}}}function Ae(e,n,t,i,r,o,a){const[s,c,l]=o,[f,p,m]=a,g=i||s!==f&&F(s)&&F(f);if(!g){const A=c.name.value,ue=p.name.value;if(A!==ue)return[[r,`"${A}" and "${ue}" are different fields`],[c],[p]];if(me(c)!==me(p))return[[r,"they have differing arguments"],[c],[p]]}const N=l==null?void 0:l.type,S=m==null?void 0:m.type;if(N&&S&&K(N,S))return[[r,`they return conflicting types "${T(N)}" and "${T(S)}"`],[c],[p]];const ce=c.selectionSet,le=p.selectionSet;if(ce&&le){const A=$n(e,n,t,g,O(N),ce,O(S),le);return An(A,r,c,p)}}function me(e){var n;const t=(n=e.arguments)!==null&&n!==void 0?n:[],i={kind:u.OBJECT,fields:t.map(r=>({kind:u.OBJECT_FIELD,name:r.name,value:r.value}))};return v(te(i))}function K(e,n){return k(e)?k(n)?K(e.ofType,n.ofType):!0:k(n)?!0:I(e)?I(n)?K(e.ofType,n.ofType):!0:I(n)?!0:V(e)||V(n)?e!==n:!1}function Y(e,n,t,i){const r=n.get(i);if(r)return r;const o=Object.create(null),a=Object.create(null);Pe(e,t,i,o,a);const s=[o,Object.keys(a)];return n.set(i,s),s}function H(e,n,t){const i=n.get(t.selectionSet);if(i)return i;const r=h(e.getSchema(),t.typeCondition);return Y(e,n,r,t.selectionSet)}function Pe(e,n,t,i,r){for(const o of t.selections)switch(o.kind){case u.FIELD:{const a=o.name.value;let s;(F(n)||w(n))&&(s=n.getFields()[a]);const c=o.alias?o.alias.value:a;i[c]||(i[c]=[]),i[c].push([n,o,s]);break}case u.FRAGMENT_SPREAD:r[o.name.value]=!0;break;case u.INLINE_FRAGMENT:{const a=o.typeCondition,s=a?h(e.getSchema(),a):n;Pe(e,s,o.selectionSet,i,r);break}}}function An(e,n,t,i){if(e.length>0)return[[n,e.map(([r])=>r)],[t,...e.map(([,r])=>r).flat()],[i,...e.map(([,,r])=>r).flat()]]}class Pn{constructor(){this._data=new Map}has(n,t,i){var r;const[o,a]=n<t?[n,t]:[t,n],s=(r=this._data.get(o))===null||r===void 0?void 0:r.get(a);return s===void 0?!1:i?!0:i===s}add(n,t,i){const[r,o]=n<t?[n,t]:[t,n],a=this._data.get(r);a===void 0?this._data.set(r,new Map([[o,i]])):a.set(o,i)}}function kn(e){return{InlineFragment(n){const t=e.getType(),i=e.getParentType();if($(t)&&$(i)&&!fe(e.getSchema(),t,i)){const r=T(i),o=T(t);e.reportError(new d(`Fragment cannot be spread here as objects of type "${r}" can never be of type "${o}".`,{nodes:n}))}},FragmentSpread(n){const t=n.name.value,i=Un(e,t),r=e.getParentType();if(i&&r&&!fe(e.getSchema(),i,r)){const o=T(r),a=T(i);e.reportError(new d(`Fragment "${t}" cannot be spread here as objects of type "${o}" can never be of type "${a}".`,{nodes:n}))}}}}function Un(e,n){const t=e.getFragment(n);if(t){const i=h(e.getSchema(),t.typeCondition);if($(i))return i}}function ke(e){const n=e.getSchema(),t=Object.create(null);for(const r of e.getDocument().definitions)q(r)&&(t[r.name.value]=r);return{ScalarTypeExtension:i,ObjectTypeExtension:i,InterfaceTypeExtension:i,UnionTypeExtension:i,EnumTypeExtension:i,InputObjectTypeExtension:i};function i(r){const o=r.name.value,a=t[o],s=n==null?void 0:n.getType(o);let c;if(a?c=Vn[a.kind]:s&&(c=jn(s)),c){if(c!==r.kind){const l=Ln(r.kind);e.reportError(new d(`Cannot extend non-${l} type "${o}".`,{nodes:a?[a,r]:r}))}}else{const l=Object.keys({...t,...n==null?void 0:n.getTypeMap()}),f=R(o,l);e.reportError(new d(`Cannot extend type "${o}" because it is not defined.`+b(f),{nodes:r.name}))}}}const Vn={[u.SCALAR_TYPE_DEFINITION]:u.SCALAR_TYPE_EXTENSION,[u.OBJECT_TYPE_DEFINITION]:u.OBJECT_TYPE_EXTENSION,[u.INTERFACE_TYPE_DEFINITION]:u.INTERFACE_TYPE_EXTENSION,[u.UNION_TYPE_DEFINITION]:u.UNION_TYPE_EXTENSION,[u.ENUM_TYPE_DEFINITION]:u.ENUM_TYPE_EXTENSION,[u.INPUT_OBJECT_TYPE_DEFINITION]:u.INPUT_OBJECT_TYPE_EXTENSION};function jn(e){if(rn(e))return u.SCALAR_TYPE_EXTENSION;if(F(e))return u.OBJECT_TYPE_EXTENSION;if(w(e))return u.INTERFACE_TYPE_EXTENSION;if(on(e))return u.UNION_TYPE_EXTENSION;if(De(e))return u.ENUM_TYPE_EXTENSION;if(C(e))return u.INPUT_OBJECT_TYPE_EXTENSION;y(!1,"Unexpected type: "+T(e))}function Ln(e){switch(e){case u.SCALAR_TYPE_EXTENSION:return"scalar";case u.OBJECT_TYPE_EXTENSION:return"object";case u.INTERFACE_TYPE_EXTENSION:return"interface";case u.UNION_TYPE_EXTENSION:return"union";case u.ENUM_TYPE_EXTENSION:return"enum";case u.INPUT_OBJECT_TYPE_EXTENSION:return"input object";default:y(!1,"Unexpected kind: "+T(e))}}function Mn(e){return{...Ue(e),Field:{leave(n){var t;const i=e.getFieldDef();if(!i)return!1;const r=new Set((t=n.arguments)===null||t===void 0?void 0:t.map(o=>o.name.value));for(const o of i.args)if(!r.has(o.name)&&_e(o)){const a=T(o.type);e.reportError(new d(`Field "${i.name}" argument "${o.name}" of type "${a}" is required, but it was not provided.`,{nodes:n}))}}}}}function Ue(e){var n;const t=Object.create(null),i=e.getSchema(),r=(n=i==null?void 0:i.getDirectives())!==null&&n!==void 0?n:B;for(const s of r)t[s.name]=j(s.args.filter(_e),c=>c.name);const o=e.getDocument().definitions;for(const s of o)if(s.kind===u.DIRECTIVE_DEFINITION){var a;const c=(a=s.arguments)!==null&&a!==void 0?a:[];t[s.name.value]=j(c.filter(Yn),l=>l.name.value)}return{Directive:{leave(s){const c=s.name.value,l=t[c];if(l){var f;const p=(f=s.arguments)!==null&&f!==void 0?f:[],m=new Set(p.map(g=>g.name.value));for(const[g,N]of Object.entries(l))if(!m.has(g)){const S=sn(N.type)?T(N.type):v(N.type);e.reportError(new d(`Directive "@${c}" argument "${g}" of type "${S}" is required, but it was not provided.`,{nodes:s}))}}}}}}function Yn(e){return e.type.kind===u.NON_NULL_TYPE&&e.defaultValue==null}function Xn(e){return{Field(n){const t=e.getType(),i=n.selectionSet;if(t){if(V(O(t))){if(i){const r=n.name.value,o=T(t);e.reportError(new d(`Field "${r}" must not have a selection since type "${o}" has no subfields.`,{nodes:i}))}}else if(!i){const r=n.name.value,o=T(t);e.reportError(new d(`Field "${r}" of type "${o}" must have a selection of subfields. Did you mean "${r} { ... }"?`,{nodes:n}))}}}}}function Bn(e,n,t){var i;const r={},o=(i=n.arguments)!==null&&i!==void 0?i:[],a=j(o,s=>s.name.value);for(const s of e.args){const c=s.name,l=s.type,f=a[c];if(!f){if(s.defaultValue!==void 0)r[c]=s.defaultValue;else if(I(l))throw new d(`Argument "${c}" of required type "${T(l)}" was not provided.`,{nodes:n});continue}const p=f.value;let m=p.kind===u.NULL;if(p.kind===u.VARIABLE){const N=p.name.value;if(t==null||!qn(t,N)){if(s.defaultValue!==void 0)r[c]=s.defaultValue;else if(I(l))throw new d(`Argument "${c}" of required type "${T(l)}" was provided the variable "$${N}" which was not provided a runtime value.`,{nodes:p});continue}m=t[N]==null}if(m&&I(l))throw new d(`Argument "${c}" of non-null type "${T(l)}" must not be null.`,{nodes:p});const g=an(p,l,t);if(g===void 0)throw new d(`Argument "${c}" has invalid value ${v(p)}.`,{nodes:p});r[c]=g}return r}function ge(e,n,t){var i;const r=(i=n.directives)===null||i===void 0?void 0:i.find(o=>o.name.value===e.name);if(r)return Bn(e,r,t)}function qn(e,n){return Object.prototype.hasOwnProperty.call(e,n)}function Gn(e,n,t,i,r){const o=new Map;return W(e,n,t,i,r,o,new Set),o}function W(e,n,t,i,r,o,a){for(const s of r.selections)switch(s.kind){case u.FIELD:{if(!Q(t,s))continue;const c=Jn(s),l=o.get(c);l!==void 0?l.push(s):o.set(c,[s]);break}case u.INLINE_FRAGMENT:{if(!Q(t,s)||!Te(e,s,i))continue;W(e,n,t,i,s.selectionSet,o,a);break}case u.FRAGMENT_SPREAD:{const c=s.name.value;if(a.has(c)||!Q(t,s))continue;a.add(c);const l=n[c];if(!l||!Te(e,l,i))continue;W(e,n,t,i,l.selectionSet,o,a);break}}}function Q(e,n){const t=ge(cn,n,e);if((t==null?void 0:t.if)===!0)return!1;const i=ge(ln,n,e);return(i==null?void 0:i.if)!==!1}function Te(e,n,t){const i=n.typeCondition;if(!i)return!0;const r=h(e,i);return r===t?!0:he(r)?e.isSubType(r,t):!1}function Jn(e){return e.alias?e.alias.value:e.name.value}function Qn(e){return{OperationDefinition(n){if(n.operation==="subscription"){const t=e.getSchema(),i=t.getSubscriptionType();if(i){const r=n.name?n.name.value:null,o=Object.create(null),a=e.getDocument(),s=Object.create(null);for(const l of a.definitions)l.kind===u.FRAGMENT_DEFINITION&&(s[l.name.value]=l);const c=Gn(t,s,o,i,n.selectionSet);if(c.size>1){const p=[...c.values()].slice(1).flat();e.reportError(new d(r!=null?`Subscription "${r}" must select only one top level field.`:"Anonymous Subscription must select only one top level field.",{nodes:p}))}for(const l of c.values())l[0].name.value.startsWith("__")&&e.reportError(new d(r!=null?`Subscription "${r}" must not select an introspection top level field.`:"Anonymous Subscription must not select an introspection top level field.",{nodes:l}))}}}}}function re(e,n){const t=new Map;for(const i of e){const r=n(i),o=t.get(r);o===void 0?t.set(r,[i]):o.push(i)}return t}function Kn(e){return{DirectiveDefinition(i){var r;const o=(r=i.arguments)!==null&&r!==void 0?r:[];return t(`@${i.name.value}`,o)},InterfaceTypeDefinition:n,InterfaceTypeExtension:n,ObjectTypeDefinition:n,ObjectTypeExtension:n};function n(i){var r;const o=i.name.value,a=(r=i.fields)!==null&&r!==void 0?r:[];for(const c of a){var s;const l=c.name.value,f=(s=c.arguments)!==null&&s!==void 0?s:[];t(`${o}.${l}`,f)}return!1}function t(i,r){const o=re(r,a=>a.name.value);for(const[a,s]of o)s.length>1&&e.reportError(new d(`Argument "${i}(${a}:)" can only be defined once.`,{nodes:s.map(c=>c.name)}));return!1}}function oe(e){return{Field:n,Directive:n};function n(t){var i;const r=(i=t.arguments)!==null&&i!==void 0?i:[],o=re(r,a=>a.name.value);for(const[a,s]of o)s.length>1&&e.reportError(new d(`There can be only one argument named "${a}".`,{nodes:s.map(c=>c.name)}))}}function Ve(e){const n=Object.create(null),t=e.getSchema();return{DirectiveDefinition(i){const r=i.name.value;if(t!=null&&t.getDirective(r)){e.reportError(new d(`Directive "@${r}" already exists in the schema. It cannot be redefined.`,{nodes:i.name}));return}return n[r]?e.reportError(new d(`There can be only one directive named "@${r}".`,{nodes:[n[r],i.name]})):n[r]=i.name,!1}}}function se(e){const n=Object.create(null),t=e.getSchema(),i=t?t.getDirectives():B;for(const s of i)n[s.name]=!s.isRepeatable;const r=e.getDocument().definitions;for(const s of r)s.kind===u.DIRECTIVE_DEFINITION&&(n[s.name.value]=!s.repeatable);const o=Object.create(null),a=Object.create(null);return{enter(s){if(!("directives"in s)||!s.directives)return;let c;if(s.kind===u.SCHEMA_DEFINITION||s.kind===u.SCHEMA_EXTENSION)c=o;else if(q(s)||be(s)){const l=s.name.value;c=a[l],c===void 0&&(a[l]=c=Object.create(null))}else c=Object.create(null);for(const l of s.directives){const f=l.name.value;n[f]&&(c[f]?e.reportError(new d(`The directive "@${f}" can only be used once at this location.`,{nodes:[c[f],l]})):c[f]=l)}}}}function je(e){const n=e.getSchema(),t=n?n.getTypeMap():Object.create(null),i=Object.create(null);return{EnumTypeDefinition:r,EnumTypeExtension:r};function r(o){var a;const s=o.name.value;i[s]||(i[s]=Object.create(null));const c=(a=o.values)!==null&&a!==void 0?a:[],l=i[s];for(const f of c){const p=f.name.value,m=t[s];De(m)&&m.getValue(p)?e.reportError(new d(`Enum value "${s}.${p}" already exists in the schema. It cannot also be defined in this type extension.`,{nodes:f.name})):l[p]?e.reportError(new d(`Enum value "${s}.${p}" can only be defined once.`,{nodes:[l[p],f.name]})):l[p]=f.name}return!1}}function Le(e){const n=e.getSchema(),t=n?n.getTypeMap():Object.create(null),i=Object.create(null);return{InputObjectTypeDefinition:r,InputObjectTypeExtension:r,InterfaceTypeDefinition:r,InterfaceTypeExtension:r,ObjectTypeDefinition:r,ObjectTypeExtension:r};function r(o){var a;const s=o.name.value;i[s]||(i[s]=Object.create(null));const c=(a=o.fields)!==null&&a!==void 0?a:[],l=i[s];for(const f of c){const p=f.name.value;Hn(t[s],p)?e.reportError(new d(`Field "${s}.${p}" already exists in the schema. It cannot also be defined in this type extension.`,{nodes:f.name})):l[p]?e.reportError(new d(`Field "${s}.${p}" can only be defined once.`,{nodes:[l[p],f.name]})):l[p]=f.name}return!1}}function Hn(e,n){return F(e)||w(e)||C(e)?e.getFields()[n]!=null:!1}function Wn(e){const n=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(t){const i=t.name.value;return n[i]?e.reportError(new d(`There can be only one fragment named "${i}".`,{nodes:[n[i],t.name]})):n[i]=t.name,!1}}}function ae(e){const n=[];let t=Object.create(null);return{ObjectValue:{enter(){n.push(t),t=Object.create(null)},leave(){const i=n.pop();i||y(!1),t=i}},ObjectField(i){const r=i.name.value;t[r]?e.reportError(new d(`There can be only one input field named "${r}".`,{nodes:[t[r],i.name]})):t[r]=i.name}}}function zn(e){const n=Object.create(null);return{OperationDefinition(t){const i=t.name;return i&&(n[i.value]?e.reportError(new d(`There can be only one operation named "${i.value}".`,{nodes:[n[i.value],i]})):n[i.value]=i),!1},FragmentDefinition:()=>!1}}function Me(e){const n=e.getSchema(),t=Object.create(null),i=n?{query:n.getQueryType(),mutation:n.getMutationType(),subscription:n.getSubscriptionType()}:{};return{SchemaDefinition:r,SchemaExtension:r};function r(o){var a;const s=(a=o.operationTypes)!==null&&a!==void 0?a:[];for(const c of s){const l=c.operation,f=t[l];i[l]?e.reportError(new d(`Type for ${l} already defined in the schema. It cannot be redefined.`,{nodes:c})):f?e.reportError(new d(`There can be only one ${l} type in schema.`,{nodes:[f,c]})):t[l]=c}return!1}}function Ye(e){const n=Object.create(null),t=e.getSchema();return{ScalarTypeDefinition:i,ObjectTypeDefinition:i,InterfaceTypeDefinition:i,UnionTypeDefinition:i,EnumTypeDefinition:i,InputObjectTypeDefinition:i};function i(r){const o=r.name.value;if(t!=null&&t.getType(o)){e.reportError(new d(`Type "${o}" already exists in the schema. It cannot also be defined in this type definition.`,{nodes:r.name}));return}return n[o]?e.reportError(new d(`There can be only one type named "${o}".`,{nodes:[n[o],r.name]})):n[o]=r.name,!1}}function Zn(e){return{OperationDefinition(n){var t;const i=(t=n.variableDefinitions)!==null&&t!==void 0?t:[],r=re(i,o=>o.variable.name.value);for(const[o,a]of r)a.length>1&&e.reportError(new d(`There can be only one variable named "$${o}".`,{nodes:a.map(s=>s.variable.name)}))}}}function xn(e){return{ListValue(n){const t=un(e.getParentInputType());if(!k(t))return _(e,n),!1},ObjectValue(n){const t=O(e.getInputType());if(!C(t))return _(e,n),!1;const i=j(n.fields,r=>r.name.value);for(const r of Object.values(t.getFields()))if(!i[r.name]&&fn(r)){const a=T(r.type);e.reportError(new d(`Field "${t.name}.${r.name}" of required type "${a}" was not provided.`,{nodes:n}))}},ObjectField(n){const t=O(e.getParentInputType());if(!e.getInputType()&&C(t)){const r=R(n.name.value,Object.keys(t.getFields()));e.reportError(new d(`Field "${n.name.value}" is not defined by type "${t.name}".`+b(r),{nodes:n}))}},NullValue(n){const t=e.getInputType();I(t)&&e.reportError(new d(`Expected value of type "${T(t)}", found ${v(n)}.`,{nodes:n}))},EnumValue:n=>_(e,n),IntValue:n=>_(e,n),FloatValue:n=>_(e,n),StringValue:n=>_(e,n),BooleanValue:n=>_(e,n)}}function _(e,n){const t=e.getInputType();if(!t)return;const i=O(t);if(!V(i)){const r=T(t);e.reportError(new d(`Expected value of type "${r}", found ${v(n)}.`,{nodes:n}));return}try{if(i.parseLiteral(n,void 0)===void 0){const o=T(t);e.reportError(new d(`Expected value of type "${o}", found ${v(n)}.`,{nodes:n}))}}catch(r){const o=T(t);r instanceof d?e.reportError(r):e.reportError(new d(`Expected value of type "${o}", found ${v(n)}; `+r.message,{nodes:n,originalError:r}))}}function et(e){return{VariableDefinition(n){const t=h(e.getSchema(),n.type);if(t!==void 0&&!pn(t)){const i=n.variable.name.value,r=v(n.type);e.reportError(new d(`Variable "$${i}" cannot be non-input type "${r}".`,{nodes:n.type}))}}}}function nt(e){let n=Object.create(null);return{OperationDefinition:{enter(){n=Object.create(null)},leave(t){const i=e.getRecursiveVariableUsages(t);for(const{node:r,type:o,defaultValue:a}of i){const s=r.name.value,c=n[s];if(c&&o){const l=e.getSchema(),f=h(l,c.type);if(f&&!tt(l,f,c.defaultValue,o,a)){const p=T(f),m=T(o);e.reportError(new d(`Variable "$${s}" of type "${p}" used in position expecting type "${m}".`,{nodes:[c,r]}))}}}}},VariableDefinition(t){n[t.variable.name.value]=t}}}function tt(e,n,t,i,r){if(I(i)&&!I(n)){if(!(t!=null&&t.kind!==u.NULL)&&!(r!==void 0))return!1;const s=i.ofType;return pe(e,n,s)}return pe(e,n,i)}const Xe=Object.freeze([Se,zn,Dn,Qn,ne,vn,et,Xn,Tn,Wn,Fe,$e,kn,_n,Zn,bn,Sn,ee,se,yn,oe,xn,Mn,nt,Fn,ae]);Object.freeze([Re,Me,Ye,je,Le,Kn,Ve,ne,ee,se,ke,we,oe,ae,Ue]);class it{constructor(n,t){this._ast=n,this._fragments=void 0,this._fragmentSpreads=new Map,this._recursivelyReferencedFragments=new Map,this._onError=t}get[Symbol.toStringTag](){return"ASTValidationContext"}reportError(n){this._onError(n)}getDocument(){return this._ast}getFragment(n){let t;if(this._fragments)t=this._fragments;else{t=Object.create(null);for(const i of this.getDocument().definitions)i.kind===u.FRAGMENT_DEFINITION&&(t[i.name.value]=i);this._fragments=t}return t[n]}getFragmentSpreads(n){let t=this._fragmentSpreads.get(n);if(!t){t=[];const i=[n];let r;for(;r=i.pop();)for(const o of r.selections)o.kind===u.FRAGMENT_SPREAD?t.push(o):o.selectionSet&&i.push(o.selectionSet);this._fragmentSpreads.set(n,t)}return t}getRecursivelyReferencedFragments(n){let t=this._recursivelyReferencedFragments.get(n);if(!t){t=[];const i=Object.create(null),r=[n.selectionSet];let o;for(;o=r.pop();)for(const a of this.getFragmentSpreads(o)){const s=a.name.value;if(i[s]!==!0){i[s]=!0;const c=this.getFragment(s);c&&(t.push(c),r.push(c.selectionSet))}}this._recursivelyReferencedFragments.set(n,t)}return t}}class rt extends it{constructor(n,t,i,r){super(t,r),this._schema=n,this._typeInfo=i,this._variableUsages=new Map,this._recursiveVariableUsages=new Map}get[Symbol.toStringTag](){return"ValidationContext"}getSchema(){return this._schema}getVariableUsages(n){let t=this._variableUsages.get(n);if(!t){const i=[],r=new ve(this._schema);Ie(n,ye(r,{VariableDefinition:()=>!1,Variable(o){i.push({node:o,type:r.getInputType(),defaultValue:r.getDefaultValue()})}})),t=i,this._variableUsages.set(n,t)}return t}getRecursiveVariableUsages(n){let t=this._recursiveVariableUsages.get(n);if(!t){t=this.getVariableUsages(n);for(const i of this.getRecursivelyReferencedFragments(n))t=t.concat(this.getVariableUsages(i));this._recursiveVariableUsages.set(n,t)}return t}getType(){return this._typeInfo.getType()}getParentType(){return this._typeInfo.getParentType()}getInputType(){return this._typeInfo.getInputType()}getParentInputType(){return this._typeInfo.getParentInputType()}getFieldDef(){return this._typeInfo.getFieldDef()}getDirective(){return this._typeInfo.getDirective()}getArgument(){return this._typeInfo.getArgument()}getEnumValue(){return this._typeInfo.getEnumValue()}}function Be(e,n,t=Xe,i,r=new ve(e)){var o;const a=(o=i==null?void 0:i.maxErrors)!==null&&o!==void 0?o:100;n||xe(!1,"Must provide document."),ze(e);const s=Object.freeze({}),c=[],l=new rt(e,n,r,p=>{if(c.length>=a)throw c.push(new d("Too many validation errors, error limit reached. Validation aborted.")),s;c.push(p)}),f=Ze(t.map(p=>p(l)));try{Ie(n,ye(r,f))}catch(p){if(p!==s)throw p}return c}function ot(e){return{Field(n){const t=e.getFieldDef(),i=t==null?void 0:t.deprecationReason;if(t&&i!=null){const r=e.getParentType();r!=null||y(!1),e.reportError(new d(`The field ${r.name}.${t.name} is deprecated. ${i}`,{nodes:n}))}},Argument(n){const t=e.getArgument(),i=t==null?void 0:t.deprecationReason;if(t&&i!=null){const r=e.getDirective();if(r!=null)e.reportError(new d(`Directive "@${r.name}" argument "${t.name}" is deprecated. ${i}`,{nodes:n}));else{const o=e.getParentType(),a=e.getFieldDef();o!=null&&a!=null||y(!1),e.reportError(new d(`Field "${o.name}.${a.name}" argument "${t.name}" is deprecated. ${i}`,{nodes:n}))}}},ObjectField(n){const t=O(e.getParentInputType());if(C(t)){const i=t.getFields()[n.name.value],r=i==null?void 0:i.deprecationReason;r!=null&&e.reportError(new d(`The input field ${t.name}.${i.name} is deprecated. ${r}`,{nodes:n}))}},EnumValue(n){const t=e.getEnumValue(),i=t==null?void 0:t.deprecationReason;if(t&&i!=null){const r=O(e.getInputType());r!=null||y(!1),e.reportError(new d(`The enum value "${r.name}.${t.name}" is deprecated. ${i}`,{nodes:n}))}}}}var st=Object.defineProperty,D=(e,n)=>st(e,"name",{value:n,configurable:!0});const at=[Re,Me,Ye,je,Le,Ve,ne,ee,se,ke,oe,ae];function qe(e,n,t,i,r){const o=Xe.filter(s=>!(s===$e||s===Se||i&&s===Fe));return t&&Array.prototype.push.apply(o,t),r&&Array.prototype.push.apply(o,at),Be(e,n,o).filter(s=>{if(s.message.indexOf("Unknown directive")!==-1&&s.nodes){const c=s.nodes[0];if(c&&c.kind===u.DIRECTIVE){const l=c.name.value;if(l==="arguments"||l==="argumentDefinitions")return!1}}return!0})}D(qe,"validateWithCustomRules");const P={Error:"Error",Warning:"Warning",Information:"Information",Hint:"Hint"},z={[P.Error]:1,[P.Warning]:2,[P.Information]:3,[P.Hint]:4},X=D((e,n)=>{if(!e)throw new Error(n)},"invariant");function Ge(e,n=null,t,i,r){var o,a;let s=null;r&&(typeof r=="string"?e+=`

`+r:e+=`

`+r.reduce((c,l)=>(c+=v(l)+`

`,c),""));try{s=en(e)}catch(c){if(c instanceof d){const l=Qe((a=(o=c.locations)===null||o===void 0?void 0:o[0])!==null&&a!==void 0?a:{line:0,column:0},e);return[{severity:z.Error,message:c.message,source:"GraphQL: Syntax",range:l}]}throw c}return Je(s,n,t,i)}D(Ge,"getDiagnostics");function Je(e,n=null,t,i){if(!n)return[];const r=Z(qe(n,e,t,i),a=>x(a,z.Error,"Validation")),o=Z(Be(n,e,[ot]),a=>x(a,z.Warning,"Deprecation"));return r.concat(o)}D(Je,"validateQuery");function Z(e,n){return Array.prototype.concat.apply([],e.map(n))}D(Z,"mapCat");function x(e,n,t){if(!e.nodes)return[];const i=[];return e.nodes.forEach(r=>{const o=r.kind!=="Variable"&&"name"in r&&r.name!==void 0?r.name:"variable"in r&&r.variable!==void 0?r.variable:r;if(o){X(e.locations,"GraphQL validation error requires locations.");const a=e.locations[0],s=Ke(o),c=a.column+(s.end-s.start);i.push({source:`GraphQL: ${t}`,message:e.message,severity:n,range:new Ne(new U(a.line-1,a.column-1),new U(a.line-1,c))})}}),i}D(x,"annotations");function Qe(e,n){const t=He(),i=t.startState(),r=n.split(`
`);X(r.length>=e.line,"Query text must have more lines than where the error happened");let o=null;for(let l=0;l<e.line;l++)for(o=new We(r[l]);!o.eol()&&t.token(o,i)!=="invalidchar";);X(o,"Expected Parser stream to be available.");const a=e.line-1,s=o.getStartOfToken(),c=o.getCurrentPosition();return new Ne(new U(a,s),new U(a,c))}D(Qe,"getRange");function Ke(e){const t=e.loc;return X(t,"Expected ASTNode to have a location."),t}D(Ke,"getLocation");const Ee=["error","warning","information","hint"],ct={"GraphQL: Validation":"validation","GraphQL: Deprecation":"deprecation","GraphQL: Syntax":"syntax"};G.registerHelper("lint","graphql",(e,n)=>{const t=n.schema;return Ge(e,t,n.validationRules,void 0,n.externalFragments).map(o=>({message:o.message,severity:o.severity?Ee[o.severity-1]:Ee[0],type:o.source?ct[o.source]:void 0,from:G.Pos(o.range.start.line,o.range.start.character),to:G.Pos(o.range.end.line,o.range.end.character)}))});
